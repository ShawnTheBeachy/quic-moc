using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using QuicMoc.Models;

namespace QuicMoc;

[Generator]
public sealed class SourceGenerator : IIncrementalGenerator
{
    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<ProxyGenerationTarget> targets
    )
    {
        foreach (var target in targets)
        {
            var sourceCode = $$"""
                // <auto-generated />
                #nullable enable

                namespace {{Constants.Namespace}};

                public sealed class ProxyFor{{target.Type.Name}} : {{target.Type.Name}}
                {
                    {{GenerateProperties(target)}}
                }

                public static partial class Mock
                {
                    public static ProxyFor{{target.Type.Name}} For<{{target.Type.Name}}>() => new();
                }
                """;
            context.AddSource(
                $"ProxyFor{target.Type.Name}.g.cs",
                SourceText.From(sourceCode, Encoding.UTF8)
            );
        }

        return;

        static string GenerateProperties(ProxyGenerationTarget target)
        {
            var props = new string[target.Properties.Count];

            for (var i = 0; i < target.Properties.Count; i++)
            {
                var prop = target.Properties[i];
                var source = $$"""
                    {{prop.Type.Name}} {{target.Type.Name}}.{{prop.Name}} => {{prop.Name}};
                    public PropertyProxy<{{prop.Type.Name}}> {{prop.Name}} { get; set; } = new();
                    """;
                props[i] = source;
            }

            return string.Join("\n\n", props);
        }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddPropertyProxySource().AddMockSource()
        );

        var precededByMock = false;
        var provider = context
            .SyntaxProvider.CreateSyntaxProvider(
                (s, _) =>
                {
                    var wasPrecededByMock = precededByMock;
                    precededByMock = s is IdentifierNameSyntax { Identifier.Text: "Mock" };

                    if (!wasPrecededByMock)
                        return false;

                    if (s is not GenericNameSyntax gns)
                        return false;

                    if (gns.Arity != 1)
                        return false;

                    if (gns.Identifier.Text != "For")
                        return false;

                    return true;
                },
                (ctx, _) => new ProxyGenerationTarget(ctx)
            )
            .Where(t => t.Type.IsAbstract);

        // Generate the source code.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, [.. t.Right.OfType<ProxyGenerationTarget>()])
        );
    }
}
